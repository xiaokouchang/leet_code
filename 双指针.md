# 双指针

## [移动零]([283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/description/))

数组分块，数组划分

利用数组下标来充当指针。

![](D:\VS_code\gitee\leet_code\图片\屏幕截图 2025-11-26 212655.png)

两个指针的作用

**cur**：从左往右扫描数组，遍历数组

**dest**：已处理的区间内，非0元素的最后一个位置

**三个区间**：[0,dest] (非0元素) [dest+1,cur-1] (0元素) [cur,n-1] (待处理的区间)

![](D:\VS_code\gitee\leet_code\图片\双指针.png)



## [复写零]([1089. 复写零 - 力扣（LeetCode）](https://leetcode.cn/problems/duplicate-zeros/description/))

先根据”异地“操作，然后优化成双指针下的”就地“操作。

**异地操作**

```c++
class Solution {
public:
    void duplicateZeros(vector<int>& arr) {
        int left = 0;
        int n = arr.size();
        vector<int> arr1;      // 记录非0元素
        vector<int> arr2(arr); // 拷贝
        arr1.resize(n);
        int i = 0;
        //找出所有非0元素
        for (left = 0; left < n; left++) {
            if (arr[left] != 0) {
                arr1[i++] = arr[left];
            }
        }
        i = 0;
        int j = 0;
        //填充元素
        for (left = 0; left < n; left++) {
            if (arr2[j] != 0) {
                arr[left] = arr1[i++];
            } else {
                arr[left] = 0;
                if (left + 1 < n) {
                    left++;
                    arr[left] = 0;
                }
            }
            j++;
        }
    }
};
```

**就地操作**

1. 找到最后一个复写的数（边界条件）
2. 从后往前完成复写
