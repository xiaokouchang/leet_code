# 双指针

## [移动零](https://leetcode.cn/problems/move-zeroes/description/)

数组分块，数组划分

利用数组下标来充当指针。

![](D:\VS_code\gitee\leet_code\图片\屏幕截图 2025-11-26 212655.png)

两个指针的作用

**cur**：从左往右扫描数组，遍历数组

**dest**：已处理的区间内，非0元素的最后一个位置

**三个区间**：[0,dest] (非0元素) [dest+1,cur-1] (0元素) [cur,n-1] (待处理的区间)

![](D:\VS_code\gitee\leet_code\图片\双指针.png)



## [复写零](https://leetcode.cn/problems/duplicate-zeros/description/)

先根据”异地“操作，然后优化成双指针下的”就地“操作。

**异地操作**

```c++
class Solution {
public:
    void duplicateZeros(vector<int>& arr) {
        int left = 0;
        int n = arr.size();
        vector<int> arr1;      // 记录非0元素
        vector<int> arr2(arr); // 拷贝
        arr1.resize(n);
        int i = 0;
        //找出所有非0元素
        for (left = 0; left < n; left++) {
            if (arr[left] != 0) {
                arr1[i++] = arr[left];
            }
        }
        i = 0;
        int j = 0;
        //填充元素
        for (left = 0; left < n; left++) {
            if (arr2[j] != 0) {
                arr[left] = arr1[i++];
            } else {
                arr[left] = 0;
                if (left + 1 < n) {
                    left++;
                    arr[left] = 0;
                }
            }
            j++;
        }
    }
};
```

**就地操作**

1. 找到最后一个复写的数（边界条件）
2. 从后往前完成复写

```c++
class Solution 
{
public:
    void duplicateZeros(vector<int>& arr) 
    {
        int n = arr.size();
        int right = -1;
        int left = 0;
        int i = 0;
        // 找到最后一个复写的数
        while (left < n) 
        {
            if (arr[left] == 0) 
            {
                right += 2;
            } 
            else 
            {
                right++;
            }
            if (right >= n - 1) 
            {
                break;
            }
            left++;
        }
        if (right == n) 
        {
            arr[n - 1] = 0;
            left--;
            right -= 2;
        }
        while (left >= 0) 
        {
            if (arr[left] == 0) 
            {
                arr[right--] = 0;
                arr[right--] = 0;
                left--;
            } 
            else 
            {
                arr[right--] = arr[left--];
            }
        }
    }
};
```

## [快乐数](https://leetcode.cn/problems/happy-number/solutions/21454/shi-yong-kuai-man-zhi-zhen-si-xiang-zhao-chu-xun-h/)

**快乐数**的定义是对一个正整数，不断将其替换为它各个位上数字的平方和，如果最终这个过程能够收敛到1，则这个数被称为快乐数。相反，如果在这个过程中形成了一个不包含1的循环，则该数不是快乐数。

**非快乐数**在重复计算各位数字的平方和的过程中不仅会形成一个循环，而且每个循环中的数字都是一样的。

**鸽巢原理（抽屉原理）**

