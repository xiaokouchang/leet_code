# 双指针

## [移动零](https://leetcode.cn/problems/move-zeroes/description/)

数组分块，数组划分

利用数组下标来充当指针。

![](D:\VS_code\gitee\leet_code\图片\屏幕截图 2025-11-26 212655.png)

两个指针的作用

**cur**：从左往右扫描数组，遍历数组

**dest**：已处理的区间内，非0元素的最后一个位置

**三个区间**：[0,dest] (非0元素) [dest+1,cur-1] (0元素) [cur,n-1] (待处理的区间)

![](D:\VS_code\gitee\leet_code\图片\双指针.png)



## [复写零](https://leetcode.cn/problems/duplicate-zeros/description/)

先根据”异地“操作，然后优化成双指针下的”就地“操作。

**异地操作**

```c++
class Solution {
public:
    void duplicateZeros(vector<int>& arr) {
        int left = 0;
        int n = arr.size();
        vector<int> arr1;      // 记录非0元素
        vector<int> arr2(arr); // 拷贝
        arr1.resize(n);
        int i = 0;
        //找出所有非0元素
        for (left = 0; left < n; left++) {
            if (arr[left] != 0) {
                arr1[i++] = arr[left];
            }
        }
        i = 0;
        int j = 0;
        //填充元素
        for (left = 0; left < n; left++) {
            if (arr2[j] != 0) {
                arr[left] = arr1[i++];
            } else {
                arr[left] = 0;
                if (left + 1 < n) {
                    left++;
                    arr[left] = 0;
                }
            }
            j++;
        }
    }
};
```

**就地操作**

1. 找到最后一个复写的数（边界条件）
2. 从后往前完成复写

```c++
class Solution 
{
public:
    void duplicateZeros(vector<int>& arr) 
    {
        int n = arr.size();
        int right = -1;
        int left = 0;
        int i = 0;
        // 找到最后一个复写的数
        while (left < n) 
        {
            if (arr[left] == 0) 
            {
                right += 2;
            } 
            else 
            {
                right++;
            }
            if (right >= n - 1) 
            {
                break;
            }
            left++;
        }
        if (right == n) 
        {
            arr[n - 1] = 0;
            left--;
            right -= 2;
        }
        while (left >= 0) 
        {
            if (arr[left] == 0) 
            {
                arr[right--] = 0;
                arr[right--] = 0;
                left--;
            } 
            else 
            {
                arr[right--] = arr[left--];
            }
        }
    }
};
```

## [快乐数](https://leetcode.cn/problems/happy-number/solutions/21454/shi-yong-kuai-man-zhi-zhen-si-xiang-zhao-chu-xun-h/)

**快乐数**的定义是对一个正整数，不断将其替换为它各个位上数字的平方和，如果最终这个过程能够收敛到1，则这个数被称为快乐数。相反，如果在这个过程中形成了一个不包含1的循环，则该数不是快乐数。

**非快乐数**在重复计算各位数字的平方和的过程中不仅会形成一个循环，而且每个循环中的数字都是一样的。

### **鸽巢原理（抽屉原理）**

n个巢，n+1个鸽子，至少有一个巢，里面的鸽数大于1。

快乐数的判定可通过鸽巢原理证明 —— 最终要么收敛到 1，要么进入循环（不会无限发散）。

1. 先明确两个关键前提

- 快乐数定义：对于正整数 n，将其每个数位的平方相加得到新数，重复该过程，若最终能得到 1，则 n 是快乐数；若陷入循环则不是。
- 鸽巢原理核心：若有更多的 “物品”（这里是迭代产生的数），放入更少的 “鸽巢”（这里是有限范围的数），则至少有一个鸽巢会放入多个物品（即出现重复数，触发循环）。

2. 鸽巢原理的具体应用

- 第一步：确定 “鸽巢” 的数量（迭代数的范围上限）。

  设 n 是 d 位数，其数位平方和的最大值为 9²×d=81d。

  当 d≥3 时，81d < 10^(d-1)（比如 3 位数最大值 999，平方和为 243 < 100；4 位数最大值 9999，平方和为 324 < 1000），即多位数的平方和会快速降为两位数或一位数。

  因此，所有迭代产生的数最终都会落入 [1, 81] 这个有限区间（两位数最大平方和为 9²+9²=162，继续迭代会降至 81 以内），“鸽巢” 总数最多 81 个。

- 第二步：分析 “物品” 的产生（迭代过程）。

  迭代会不断产生新数，且每次产生的数都属于 [1, 81] 这个有限区间（即 “鸽巢” 集合）。

  由于迭代次数可以无限进行，产生的数（“物品”）数量会超过鸽巢数量（81 个）。

- 第三步：推导结论（收敛或循环）。

  根据鸽巢原理，必然存在重复的数，即迭代过程会进入循环。

  而循环只有两种可能：一种是包含 1（此时所有后续数都会是 1，即快乐数），另一种是不包含 1（此时陷入非 1 的循环，不是快乐数）。

  因此，快乐数的判定无需无限迭代，只需检查是否出现 1 或重复数即可。

```C++
class Solution 
{
public:
    int squresum(int num) 
    {
        int sum = 0;
        while (num > 0) 
        {
            int n = num % 10;
            sum += n * n;
            num /= 10;
        }
        return sum;
    }
    bool isHappy(int n) 
    {
        int slow = n;
        int fast = n;
        do
        {
            slow=squresum(slow);
            fast=squresum(fast);
            fast=squresum(fast);
        }while(slow!=fast);
        return slow == 1;
    }
};
```

## [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/)

**解法1---暴力枚举**

**解法2---双指针**

左指针从左向右移动，右指针从右向左移动，也就是随着左右指针不断移动，宽度在逐渐减小，左右指针谁的高度小就移动谁，保证高度为最低高度（木桶的短板），即最大高度，盛的水才能最多。

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int n = height.size();
        int right = n - 1;
        int area = 0;
        int maxarea = 0;
        while(left<right)
        {
            area=(right-left)*min(height[left],height[right]);
            maxarea=max(area,maxarea);
            //谁小移动谁
            if(height[left]<height[right])
            {
                left++;
            }
            else 
            {
                right--;
            }
        }
        return maxarea;
    }
};
```



## [有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

**方法1（暴力枚举）**

对每组三个数，按以下流程判断：

1. 检查是否均为正数（>=0）；
2. 判断最短两边之和是否大于最长边（3次判断）；

**方法2**（优化）

对每组三个数，按以下流程判断：

1. 检查是否均为正数（>=0）；
2. 排序
3. 排序后判断最短两边之和是否大于最长边（1次判断，2条短边大于第3条长边）；

![](D:\VS_code\gitee\leet_code\图片\屏幕截图 2025-12-04 210450.png)
