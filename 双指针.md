# 双指针

## [移动零](https://leetcode.cn/problems/move-zeroes/description/)

数组分块，数组划分

利用数组下标来充当指针。

![](D:\VS_code\gitee\leet_code\图片\屏幕截图 2025-11-26 212655.png)

两个指针的作用

**cur**：从左往右扫描数组，遍历数组

**dest**：已处理的区间内，非0元素的最后一个位置

**三个区间**：[0,dest] (非0元素) [dest+1,cur-1] (0元素) [cur,n-1] (待处理的区间)

![](D:\VS_code\gitee\leet_code\图片\双指针.png)



## [复写零](https://leetcode.cn/problems/duplicate-zeros/description/)

先根据”异地“操作，然后优化成双指针下的”就地“操作。

**异地操作**

```c++
class Solution {
public:
    void duplicateZeros(vector<int>& arr) {
        int left = 0;
        int n = arr.size();
        vector<int> arr1;      // 记录非0元素
        vector<int> arr2(arr); // 拷贝
        arr1.resize(n);
        int i = 0;
        //找出所有非0元素
        for (left = 0; left < n; left++) {
            if (arr[left] != 0) {
                arr1[i++] = arr[left];
            }
        }
        i = 0;
        int j = 0;
        //填充元素
        for (left = 0; left < n; left++) {
            if (arr2[j] != 0) {
                arr[left] = arr1[i++];
            } else {
                arr[left] = 0;
                if (left + 1 < n) {
                    left++;
                    arr[left] = 0;
                }
            }
            j++;
        }
    }
};
```

**就地操作**

1. 找到最后一个复写的数（边界条件）
2. 从后往前完成复写

```c++
class Solution 
{
public:
    void duplicateZeros(vector<int>& arr) 
    {
        int n = arr.size();
        int right = -1;
        int left = 0;
        int i = 0;
        // 找到最后一个复写的数
        while (left < n) 
        {
            if (arr[left] == 0) 
            {
                right += 2;
            } 
            else 
            {
                right++;
            }
            if (right >= n - 1) 
            {
                break;
            }
            left++;
        }
        if (right == n) 
        {
            arr[n - 1] = 0;
            left--;
            right -= 2;
        }
        while (left >= 0) 
        {
            if (arr[left] == 0) 
            {
                arr[right--] = 0;
                arr[right--] = 0;
                left--;
            } 
            else 
            {
                arr[right--] = arr[left--];
            }
        }
    }
};
```

## [快乐数](https://leetcode.cn/problems/happy-number/solutions/21454/shi-yong-kuai-man-zhi-zhen-si-xiang-zhao-chu-xun-h/)

**快乐数**的定义是对一个正整数，不断将其替换为它各个位上数字的平方和，如果最终这个过程能够收敛到1，则这个数被称为快乐数。相反，如果在这个过程中形成了一个不包含1的循环，则该数不是快乐数。

**非快乐数**在重复计算各位数字的平方和的过程中不仅会形成一个循环，而且每个循环中的数字都是一样的。

### **鸽巢原理（抽屉原理）**

n个巢，n+1个鸽子，至少有一个巢，里面的鸽数大于1。

快乐数的判定可通过鸽巢原理证明 —— 最终要么收敛到 1，要么进入循环（不会无限发散）。

1. 先明确两个关键前提

- 快乐数定义：对于正整数 n，将其每个数位的平方相加得到新数，重复该过程，若最终能得到 1，则 n 是快乐数；若陷入循环则不是。
- 鸽巢原理核心：若有更多的 “物品”（这里是迭代产生的数），放入更少的 “鸽巢”（这里是有限范围的数），则至少有一个鸽巢会放入多个物品（即出现重复数，触发循环）。

2. 鸽巢原理的具体应用

- 第一步：确定 “鸽巢” 的数量（迭代数的范围上限）。

  设 n 是 d 位数，其数位平方和的最大值为 9²×d=81d。

  当 d≥3 时，81d < 10^(d-1)（比如 3 位数最大值 999，平方和为 243 < 100；4 位数最大值 9999，平方和为 324 < 1000），即多位数的平方和会快速降为两位数或一位数。

  因此，所有迭代产生的数最终都会落入 [1, 81] 这个有限区间（两位数最大平方和为 9²+9²=162，继续迭代会降至 81 以内），“鸽巢” 总数最多 81 个。

- 第二步：分析 “物品” 的产生（迭代过程）。

  迭代会不断产生新数，且每次产生的数都属于 [1, 81] 这个有限区间（即 “鸽巢” 集合）。

  由于迭代次数可以无限进行，产生的数（“物品”）数量会超过鸽巢数量（81 个）。

- 第三步：推导结论（收敛或循环）。

  根据鸽巢原理，必然存在重复的数，即迭代过程会进入循环。

  而循环只有两种可能：一种是包含 1（此时所有后续数都会是 1，即快乐数），另一种是不包含 1（此时陷入非 1 的循环，不是快乐数）。

  因此，快乐数的判定无需无限迭代，只需检查是否出现 1 或重复数即可。

```C++
class Solution 
{
public:
    int squresum(int num) 
    {
        int sum = 0;
        while (num > 0) 
        {
            int n = num % 10;
            sum += n * n;
            num /= 10;
        }
        return sum;
    }
    bool isHappy(int n) 
    {
        int slow = n;
        int fast = n;
        do
        {
            slow=squresum(slow);
            fast=squresum(fast);
            fast=squresum(fast);
        }while(slow!=fast);
        return slow == 1;
    }
};
```

## [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/)

**解法1---暴力枚举**

**解法2---双指针**

左指针从左向右移动，右指针从右向左移动，也就是随着左右指针不断移动，宽度在逐渐减小，左右指针谁的高度小就移动谁，保证高度为最低高度（木桶的短板），即最大高度，盛的水才能最多。

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int n = height.size();
        int right = n - 1;
        int area = 0;
        int maxarea = 0;
        while(left<right)
        {
            area=(right-left)*min(height[left],height[right]);
            maxarea=max(area,maxarea);
            //谁小移动谁
            if(height[left]<height[right])
            {
                left++;
            }
            else 
            {
                right--;
            }
        }
        return maxarea;
    }
};
```



## [有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

**方法1（暴力枚举）**

对每组三个数，按以下流程判断：

1. 检查是否均为正数（>=0）；
2. 判断最短两边之和是否大于最长边（3次判断）；

**方法2**（优化）

对每组三个数，按以下流程判断：

1. 检查是否均为正数（>=0）；
2. 排序
3. 排序后判断最短两边之和是否大于最长边（1次判断，2条短边大于第3条长边）；

![](D:\VS_code\gitee\leet_code\图片\屏幕截图 2025-12-04 210450.png)

## [四数之和](https://leetcode.cn/problems/4sum/solutions/1/ji-zhi-you-hua-ji-yu-san-shu-zhi-he-de-z-1f0b/)

在代码中对 `nums[i]` 进行 `long long` 强制类型转换，核心目的是**避免整数溢出**。**强制类型转换时只要有一个操作数被转换，其余会自动提升，因此只需转换第一个即可。**

```C++
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) 
    {
        vector<vector<int>> result;
        int n = nums.size();
        // 边界条件：数组长度不足4时直接返回空
        if (n < 4) return result;    
        // 排序是双指针的前提
        sort(nums.begin(), nums.end());
        // 第一层循环：固定第一个数
        for (int i = 0; i <= n - 4; ++i) 
        {
            // 去重：跳过与前一个数重复的情况
            if (i > 0 && nums[i] == nums[i - 1]) 
            {
                continue;
            }
            // 剪枝1：当前i的最小四数和 > target，后续更大，直接break
            long long min_sum_i = (long long)nums[i] + nums[i+1] + nums[i+2] + nums[i+3];
            if (min_sum_i > target) 
            {
                break;
            }
            // 剪枝2：当前i的最大四数和 < target，当前i无解，continue
            long long max_sum_i = (long long)nums[i] + nums[n-3] + nums[n-2] + nums[n-1];
            if (max_sum_i < target) 
            {
                continue;
            }
            // 第二层循环：固定第二个数
            for (int j = i + 1; j <= n - 3; ++j) 
            {
                // 去重：跳过与前一个数重复的情况（注意j > i+1）
                if (j > i + 1 && nums[j] == nums[j - 1]) 
                {
                    continue;
                }
                // 剪枝3：当前i+j的最小四数和 > target，break
                long long min_sum_j = (long long)nums[i] + nums[j]+nums[j+1] + nums[j+2];
                if (min_sum_j > target)
                {
                    break;
                }
                // 剪枝4：当前i+j的最大四数和 < target，continue
                long long max_sum_j = (long long)nums[i] + nums[j] + nums[n-2]+nums[n-1];
                if (max_sum_j < target) 
                {
                    continue;
                }
                // 双指针：第三、第四个数
                int left = j + 1, right = n - 1;
                while (left < right) 
                {
                    // 用long long避免int溢出
                    long long sum = (long long)nums[i] + nums[j]+nums[left]+ nums[right]; 
                    if (sum == target) 
                    {
                        // 找到符合条件的四元组
                        result.push_back({nums[i], nums[j], nums[left], nums[right]});   
                        // 去重：跳过left重复值
                        while (left < right && nums[left] == nums[left + 1]) 
                        {
                            ++left;
                        }
                        // 去重：跳过right重复值
                        while (left < right && nums[right] == nums[right - 1]) 
                        {
                            --right;
                        }
                        // 移动指针找下一组
                        ++left;
                        --right;
                    } 
                    else if (sum < target) 
                    {
                        // 和太小，左指针右移增大和
                        ++left;
                    } 
                    else 
                    {
                        // 和太大，右指针左移减小和
                        --right;
                    }
                }
            }
        }
        return result;
    }
};
```

