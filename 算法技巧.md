# 最大公因数与最小公倍数

任意正偶数与2的最大公约数为2，任意正奇数与2的最大公约数为1。

[最小公倍数](https://leetcode.cn/problems/smallest-even-multiple/solutions/2236371/zui-xiao-ou-bei-shu-by-leetcode-solution-vy2o/?envType=study-plan-v2&envId=primers-list)

[最大公因数与最小公倍数](https://blog.csdn.net/2301_78847073/article/details/145835232?spm=1001.2014.3001.5501)

```c++
#include<stdio.h>
int main()
{
	long long m = 0, n = 0;
	long long i = 0, b = 0, j = 0;
	scanf("%lld %lld", &m, &n);
	//确保m >= n
	if (m < n)
	{
		m = m + n;
		n = m - n;
		m = m - n;
	}
	//求m和n的最大公因数
	while (n != 0)
	{
		i = m % n;
		m = n;
		n = i;
	}
	//求m和n的最小公倍数
	b = m * n;
	j = b / m;
	printf("%lld\n", m + j);
	return 0;
}

```

# 数组

数组总共有n个元素，循环遍历i个元素，边界条件为n-i+1

```c++
//size 6
//循环遍历3个元素
for(int i = 0;i < n - 3 + 1;i++)
```

# 字母的大小写转换

## 位运算

## 全转小写：ch |= 32

**规则**：有1为1，否则为0。

`A` 的二进制是 `01000001`（65）

32 的二进制是 `00100000`（32）

按位或后：`01100001`（97），正好是小写 `a` 的 ASCII 码。

**小写字母（比如 `a=97`）**

二进制是 `01100001`

和 32（`00100000`）按位或后还是 `01100001`（因为第 6 位已经是 1），所以小写字母不变。

## 全转大写：ch &= -33 (原理是32的补码（原码取反 + 1）再 - 1)

**规则**：全1为 1，否则为 0。

33 的二进制是 `00100001`，其补码（-33）为 `11011111`（按位取反后加 1）。

**空格字符的 ASCII 码与转换结果**：原字符串中的空格字符（`' '`）的 ASCII 码是 **32**，其 8 位二进制是 `00100000`。

`00100000`&=`11011111`  =`00000000`。`00000000`是空字符 `\0`。 `\0`在输出时不会显示任何可见符号。

## 大小写对换（大写变小写，小写变大）ch ^= 32

```c++
#include<iostream>
#include<string>
#include<vector>
using namespace std;
int main()
{
	string s("Hello World");
	for (auto &ch : s)
	{
		//ch |= 32;  //全转小写
		//ch &= -33; //全转大写
		ch ^= 32;	 //大小写转换
	}
	cout << s << endl;
	return 0;
}
```

# 2的幂

一个数n是2的幂，当且仅当n是正整数，并且n的二进制表示中仅包含1个1。使用位运算，将n的二进制表示中最低位的那个1提取出来，再判断剩余的数值是否为0即可。

## n & (n - 1)

![1758371577099](C:\Users\34242\AppData\Roaming\Typora\typora-user-images\1758371577099.png)

## n&(-n)

![1758371639552](C:\Users\34242\AppData\Roaming\Typora\typora-user-images\1758371639552.png)

## 判断是否为最大 2 的幂的约数

![1758371947266](C:\Users\34242\AppData\Roaming\Typora\typora-user-images\1758371947266.png)

# 位运算

[位运算](https://leetcode.cn/discuss/post/3580371/fen-xiang-gun-ti-dan-wei-yun-suan-ji-chu-nth4/)

[重新排列数组](https://leetcode.cn/problems/shuffle-the-array/solutions/1/kong-jian-fu-za-du-wei-o1-de-liang-chong-jie-fa-by/?envType=study-plan-v2&envId=primers-list)

# 一个数的每一位

**方法1**

利用 **取余（%10）**获取最后一位，再通过**整除（/10）** 去掉最后一位，循环直到数变为 0。

适用于整数（正数 / 负数需先处理符号）。

```c++
void getDigitsByMath(int num) 
{
    // 处理负数（转为正数，不影响各位数字）
    num = abs(num);  
    if (num == 0) 
    { 
        // 特殊处理0的情况
        cout << 0 << endl;
        return;
    }
    cout << "各位数字（从低位到高位）：";
    while (num > 0) 
    {
        int digit = num % 10; // 获取最后一位
        cout << digit << " ";
        num = num / 10;       // 去掉最后一位
    }
    cout << endl;

    // 若需从高位到低位，可先存入数组再逆序输出
    cout << "各位数字（从高位到低位）：";
    int temp = abs(num); // 恢复原始数（注意num已被修改，需重新赋值）
    int digits[10] = {0}; // 存储各位（最多10位整数）
    int count = 0;
    while (temp > 0) 
    {
        digits[count++] = temp % 10;
        temp /= 10;
    }
    for (int i = count - 1; i >= 0; --i) 
    {
        cout << digits[i] << " ";
    }
    cout << endl;
}
```

**方法2**

将数字转为字符串，遍历每个字符，再转换为数字。

适用于整数 / 浮点数（需处理小数点，浮点数建议先转字符串再处理）。

```c++
void getDigitsByString(long long num) 
{ 	
    // 用long long避免溢出
    string s = to_string(num); // 转为字符串
    cout << "各位数字：";
    for (char c : s) {
        if (c == '-') continue; // 跳过负号
        int digit = c - '0';    // 字符转数字（ASCII码差值）
        cout << digit << " ";
    }
    cout << endl;
}

// 处理浮点数示例（提取所有数字，忽略小数点）
void getDigitsOfFloat(double num) 
{
    string s = to_string(num);
    cout << "浮点数各位数字：";
    for (char c : s) {
        if (isdigit(c)) { // 判断是否为数字字符
            cout << (c - '0') << " ";
        }
    }
    cout << endl;
}
```

# [快乐数](https://leetcode.cn/problems/happy-number/)

**快乐数**定义为：

1. 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。

2. 然后重复这个过程直到这个数变为1，也可能是**无限循环**但始终变不到1。

3. 如果这个过程**结果为**1，那么这个数就是快乐数。

**解释**

快乐数的定义是基于一个计算过程，即对一个正整数，不断将其替换为它各个位上数字的平方和，如果最终这个过程能够收敛到1，则这个数被称为快乐数。相反，如果在这个过程中形成了一个不包含1的循环，则该数不是快乐数。对于非快乐数，它们的平方和序列会进入一个固定的循环，例如4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4。

为了证明每个循环的数字都是一样的，我们可以使用数学中的不动点理论。在一个有限的系统中，重复应用一个确定的操作最终会达到一个循环，这是因为系统的状态是有限的。在快乐数的情况下，由于每次计算都是基于有限的数字（0-9）的平方，因此可能的结果也是有限的。这意味着，如果我们从某个数字开始，不断重复计算它的各位数字的平方和，最终必然会进入一个循环，因为可能的平方和是有限的，而且每次计算都是确定性的。

此外，由于每个非快乐数都会进入一个固定的循环，而这个循环不包含1，这意味着循环中的所有数字都是固定的，并且每次遇到同一个数字时，都会得到相同的下一个数字。这就是为什么每个循环的数字都是一样的。

综上所述，我们可以得出结论，对于**非快乐数，它们在重复计算各位数字的平方和的过程中不仅会形成一个循环，而且每个循环中的数字都是一样的**。这一结论是基于有限性原理和确定性操作的重复应用。

![image-20251130215843117](D:\VS_code\gitee\leet_code\图片\非快乐数)
